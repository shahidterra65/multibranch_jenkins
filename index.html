<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>My-ping-Pong2 — Play in Your Browser</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:#0b0b0b; color:#eee; display:flex; align-items:center; justify-content:center; flex-direction:column; }
    h1 { margin:12px 0 6px; font-size:20px; }
    canvas { background:#111; border:3px solid #222; display:block; }
    #hud { margin:10px; display:flex; gap:12px; align-items:center; }
    button { padding:6px 10px; border-radius:6px; border:none; cursor:pointer; }
    .hint { font-size:13px; color:#bbb; }
  </style>
</head>
<body>
  <h1>My PingPong2 — W/S and ↑/↓ (or let ME play)</h1>
  <div id="hud">
    <div id="score">0 : 0</div>
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
    <div class="hint">Space = Pause • R = Reset</div>
  </div>
  <canvas id="c" width="800" height="500"></canvas>

  <script>
    // --- Setup
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // paddles
    const P_W = 12, P_H = 100;
    const P_SPEED = 6;
    const left = { x: 20, y: (H - P_H)/2 };
    const right = { x: W - 20 - P_W, y: (H - P_H)/2 };

    // ball
    const BALL_R = 8;
    let ball = { x: W/2, y: H/2, vx: 6 * (Math.random() > 0.5 ? 1 : -1), vy: 3 * (Math.random() > 0.5 ? 1 : -1) };

    let leftScore = 0, rightScore = 0;
    const scoreEl = document.getElementById('score');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');

    let paused = false;

    // input state
    const keys = { w:false, s:false, up:false, down:false };

    document.addEventListener('keydown', (e)=>{
      if (e.key === 'w' || e.key === 'W') keys.w = true;
      if (e.key === 's' || e.key === 'S') keys.s = true;
      if (e.key === 'ArrowUp') keys.up = true;
      if (e.key === 'ArrowDown') keys.down = true;
      if (e.code === 'Space') togglePause();
      if (e.key === 'r' || e.key === 'R') resetGame();
    });
    document.addEventListener('keyup', (e)=>{
      if (e.key === 'w' || e.key === 'W') keys.w = false;
      if (e.key === 's' || e.key === 'S') keys.s = false;
      if (e.key === 'ArrowUp') keys.up = false;
      if (e.key === 'ArrowDown') keys.down = false;
    });

    pauseBtn.addEventListener('click', togglePause);
    resetBtn.addEventListener('click', resetGame);

    function togglePause(){
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    }

    function resetBall(toRight){
      ball.x = W/2;
      ball.y = H/2;
      // randomize vertical a bit
      ball.vx = (toRight ? 1 : -1) * (5 + Math.random()*2);
      ball.vy = (Math.random() - 0.5) * 6;
    }

    function resetGame(){
      leftScore = 0; rightScore = 0;
      updateScore();
      resetBall(Math.random() > 0.5);
      paused = false;
      pauseBtn.textContent = 'Pause';
    }

    function updateScore(){ scoreEl.textContent = `${leftScore} : ${rightScore}`; }

    // simple collision paddle vs ball
    function paddleHit(paddle){
      // paddle edges
      return (ball.x - BALL_R < paddle.x + P_W && ball.x + BALL_R > paddle.x &&
              ball.y + BALL_R > paddle.y && ball.y - BALL_R < paddle.y + P_H);
    }

    // draw
    function draw(){
      ctx.clearRect(0,0,W,H);

      // middle dashed line
      ctx.fillStyle = '#222';
      const dashH = 12, gap = 8;
      for(let y=0; y<H; y += dashH + gap){
        ctx.fillRect(W/2 - 2, y, 4, dashH);
      }

      // paddles
      ctx.fillStyle = '#fff';
      ctx.fillRect(left.x, left.y, P_W, P_H);
      ctx.fillRect(right.x, right.y, P_W, P_H);

      // ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI*2);
      ctx.fill();

      // scores are handled in DOM
    }

    // update physics
    function update(){
      // paddles controlled by keys
      if (keys.w) left.y -= P_SPEED;
      if (keys.s) left.y += P_SPEED;
      // right paddle: user if arrow keys else simple AI
      const rightUser = keys.up || keys.down;
      if (rightUser){
        if (keys.up) right.y -= P_SPEED;
        if (keys.down) right.y += P_SPEED;
      } else {
        // simple AI: move toward ball, limited speed
        const center = right.y + P_H/2;
        if (Math.abs(center - ball.y) > 8){
          right.y += (ball.y > center) ? 3.6 : -3.6;
        }
      }

      // keep paddles inside canvas
      left.y = Math.min(Math.max(0, left.y), H - P_H);
      right.y = Math.min(Math.max(0, right.y), H - P_H);

      // move ball
      ball.x += ball.vx;
      ball.y += ball.vy;

      // top/bottom bounce
      if (ball.y - BALL_R < 0){ ball.y = BALL_R; ball.vy *= -1; }
      if (ball.y + BALL_R > H){ ball.y = H - BALL_R; ball.vy *= -1; }

      // paddle collisions
      if (paddleHit(left) && ball.vx < 0){
        ball.x = left.x + P_W + BALL_R; // nudge out
        // reflect and add angle based on where it hit
        const hitPos = (ball.y - (left.y + P_H/2)) / (P_H/2); // -1 .. 1
        ball.vx = Math.abs(ball.vx) + 0.6; // speed up slightly
        ball.vy = hitPos * 6;
      }
      if (paddleHit(right) && ball.vx > 0){
        ball.x = right.x - BALL_R;
        const hitPos = (ball.y - (right.y + P_H/2)) / (P_H/2);
        ball.vx = -Math.abs(ball.vx) - 0.6;
        ball.vy = hitPos * 6;
      }

      // scoring
      if (ball.x < 0){
        // right scores
        rightScore++;
        updateScore();
        resetBall(true);
      }
      if (ball.x > W){
        // left scores
        leftScore++;
        updateScore();
        resetBall(false);
      }
    }

    // main loop
    function loop(){
      if (!paused){
        update();
      }
      draw();
      requestAnimationFrame(loop);
    }

    // start
    updateScore();
    resetBall(Math.random()>0.5);
    requestAnimationFrame(loop);
  </script>
</body>
</html>